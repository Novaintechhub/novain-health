rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is a participant in an appointment
    function isAppointmentParticipant(appointmentId) {
      let appointment = get(/databases/$(database)/documents/appointments/$(appointmentId)).data;
      return request.auth.uid == appointment.patientId || request.auth.uid == appointment.doctorId;
    }

    match /appointments/{appointmentId} {
      // Allow read/write only if the user is the patient or the doctor for this appointment
      allow read, update: if isAppointmentParticipant(appointmentId);
      
      // Allow create only if the patient is the one creating their own appointment
      allow create: if request.resource.data.patientId == request.auth.uid;
      
      // Messages Subcollection
      match /messages/{messageId} {
        // Allow read/write only to appointment participants
        allow list, read, create: if isAppointmentParticipant(appointmentId);
      }
    }

    match /calls/{appointmentId} {
      // The user must be a participant in the appointment to interact with the call document
      allow read: if isAppointmentParticipant(appointmentId);

      // Only the caller can create the initial call document with their offer
      allow create: if isAppointmentParticipant(appointmentId) && request.resource.data.callerId == request.auth.uid;

      // Only the callee (not the original caller) can update the document to add an answer.
      // Other status updates can be handled via backend functions if needed.
      allow update: if isAppointmentParticipant(appointmentId) && get(/databases/$(database)/documents/calls/$(appointmentId)).data.callerId != request.auth.uid;

      // Allow either participant to delete the call document (e.g., on hang-up)
      allow delete: if isAppointmentParticipant(appointmentId);

      // ICE Candidates Subcollections
      match /callerCandidates/{candidateId} {
        // Only the original caller can add their ICE candidates
        allow create: if isAppointmentParticipant(appointmentId) && get(/databases/$(database)/documents/calls/$(appointmentId)).data.callerId == request.auth.uid;
        allow read: if isAppointmentParticipant(appointmentId);
      }
      
      match /calleeCandidates/{candidateId} {
        // Only the callee can add their ICE candidates
        allow create: if isAppointmentParticipant(appointmentId) && get(/databases/$(database)/documents/calls/$(appointmentId)).data.callerId != request.auth.uid;
        allow read: if isAppointmentParticipant(appointmentId);
      }
    }

    // Security rules for other collections
    match /doctors/{doctorId} {
      allow read: if true; // Publicly readable
      allow write: if request.auth.uid == doctorId; // Only the doctor can write to their own profile
      
      // Subcollections
      match /{allPaths=**} {
        allow read: if true;
        allow write: if request.auth.uid == doctorId;
      }
    }

    match /patients/{patientId} {
      allow read, write: if request.auth.uid == patientId; // Only the patient can access their own profile
    }

    match /counters/{counterId} {
        // Generally, these should only be updated by a backend process/admin.
        // For this app, we'll lock it down.
        allow read, write: if false; 
    }
    
    match /notifications/{notificationId} {
      allow read, write: if request.auth.uid == resource.data.userId;
    }
  }
}
